---
aliases: [原型与继承 ]
author: lgf
created: 45_2022-11-12 19:15:01
modified: 45_2022-11-12 19:55:42
tags: [learn/program/javascript]
title: 原型与继承 
---
# 原型与继承
## 原型基础

> 向军大叔每晚八点在 [抖音 (opens new window)](https://live.douyin.com/houdunren) 和 [bilibli (opens new window)](https://space.bilibili.com/282190994) 直播

### 原型对象

每个对象都有一个原型`prototype`对象，通过函数创建的对象也将拥有这个原型对象。原型是一个指向对象的指针。

-   可以将原型理解为对象的父亲，对象从原型对象继承来属性
-   原型就是对象除了是某个对象的父母外没有什么特别之处
-   所有函数的原型默认是 `Object`的实例，所以可以使用`toString/toValues/isPrototypeOf` 等方法的原因
-   使用原型对象为多个对象共享属性或方法
-   如果对象本身不存在属性或方法将到原型上查找
-   使用原型可以解决，通过构建函数创建对象时复制多个函数造成的内存占用问题
-   原型包含 `constructor` 属性，指向构造函数
-   对象包含 `__proto__` 指向他的原型对象

下例使用的就是数组原型对象的 `concat` 方法完成的连接操作

默认情况下创建的对象都有原型

![image-20191205163626698](https://doc.houdunren.com/assets/img/image-20191205163626698.7576e2ba.png)

以下 x、y 的原型都为元对象 Object，即 JS 中的根对象

我们也可以创建一个极简对象（纯数据字典对象）没有原型（原型为 null)

![image-20191205163809670](https://doc.houdunren.com/assets/img/image-20191205163809670.f473ca14.png)

函数拥有多个原型，`prototype` 用于实例对象使用，`__proto__`用于函数对象使用

下面是原型关系分析，与方法继承的示例

![image-20191208003927158](https://doc.houdunren.com/assets/img/image-20191208003927158.2f7f84ab.png)

下面是使用构造函数创建对象的原型体现

-   构造函数拥有原型
-   创建对象时构造函数把原型赋予对象

![image-20191010023843179](https://doc.houdunren.com/assets/img/image-20191010023843179.58edd59f.png)

下面使用数组会产生多级继承即原型链

![image-20191120174145258](https://doc.houdunren.com/assets/img/image-20191120174145258.aec2cd6d.png)

下面使用 `setPrototypeOf` 与 `getPrototypeOf` 获取与设置原型

使用自定义构造函数创建的对象的原型体现

![image-20191120174956195](https://doc.houdunren.com/assets/img/image-20191120174956195.700031e6.png)

constructor 存在于 prototype 原型中，用于指向构建函数的引用。

使用对象的 `constructor` 创建对象

### 原型链

通过引用类型的原型，继承另一个引用类型的属性与方法，这就是实现继承的步骤。

![image-20191010012103033](https://doc.houdunren.com/assets/img/image-20191010012103033.3540a960.png)

使用`Object.setPrototypeOf` 可设置对象的原型，下面的示例中继承关系为 obj>hd>cms。

`Object.getPrototypeOf` 用于获取一个对象的原型。

### 原型检测

instanceof 检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

使用`isPrototypeOf`检测一个对象是否是另一个对象的原型链中

### 属性遍历

使用`in` 检测原型链上是否存在属性，使用 `hasOwnProperty` 只检测当前对象

使用 `for/in` 遍历时同时会遍历原型上的属性如下例

`hasOwnProperty` 方法判断对象是否存在属性，而不会查找原型。所以如果只想遍历对象属性使用以下代码

### 借用原型

使用 `call` 或 `apply` 可以借用其他原型方法完成功能。

下面的 xj 对象不能使用`max`方法，但可以借用 hd 对象的原型方法

上例中如果方法可以传参，那就可以不在 `xj` 对象中定义 `getter` 方法了

因为 `Math.max` 就是获取最大值的方法，所以代码可以再次优化

下面是获取设置了 `class` 属性的按钮，但 DOM 节点不能直接使用数组的`filter` 等方法，但借用数组的原型方法就可以操作了。

### This

`this` 不受原型继承影响，`this` 指向调用属性时使用的对象。

## 原型总结

### Prototype

函数也是对象也有原型，函数有 `prototype` 属性指向他的原型

为构造函数设置的原型指，当使用构造函数创建对象时把这个原型赋予给这个对象

函数默认`prototype` 指包含一个属性 `constructor` 的对象，`constructor` 指向当前构造函数

原型中保存引用类型会造成对象共享属性，所以一般只会在原型中定义方法。

为 Object 原型对象添加方法，将影响所有函数

了解了原型后可以为系统对象添加方法，比如为字符串添加了一截断函数。

-   不能将系统对象的原型直接赋值

### Object.create

使用`Object.create`创建一个新对象时使用现有对象做为新对象的原型对象

![image-20191205153548377](https://doc.houdunren.com/assets/img/image-20191205153548377.2d54d9db.png)

使用`Object.create` 设置对象原型

强以在设置时使用第二个参数设置新对象的属性

### \_\_proto\_\_

在实例化对象上存在 \_\_proto\_\_ 记录了原型，所以可以通过对象访问到原型的属性或方法。

-   `__proto__` 不是对象属性，理解为`prototype` 的 `getter/setter` 实现，他是一个非标准定义
-   `__proto__` 内部使用`getter/setter` 控制值，所以只允许对象或 null
-   建议使用 `Object.setPrototypeOf` 与`Object.getProttoeypOf` 替代 `__proto__`

下面修改对象的 `__proto__` 是不会成功的，因为`_proto__` 内部使用`getter/setter` 控制值，所以只允许对象或 null

下面定义的`__proto__` 就会成功，因为这是一个极简对象，没有原型对象所以不会影响`__proto__`赋值。

下面通过改变对象的 `__proto__` 原型对象来实现继承，继承可以实现多层,

![image-20191205121620242](https://doc.houdunren.com/assets/img/image-20191205121620242.d709e234.png)

构造函数中的 `__proto__` 使用

可以使用 `__proto__` 或 `Object.setPrototypeOf` 设置对象的原型，使用`Object.getProttoeypOf` 获取对象原型。

对象设置属性，只是修改对象属性并不会修改原型属性，使用`hasOwnProperty` 判断对象本身是否含有属性并不会检测原型。

使用 `in` 会检测原型与对象，而 `hasOwnProperty` 只检测对象，所以结合后可判断属性是否在原型中

### 使用建议

通过前介绍我们知道可以使用多种方式设置原型，下面是按时间顺序的排列

1.  `prototype` 构造函数的原型属性
2.  `Object.create` 创建对象时指定原型
3.  `__proto__` 声明自定义的非标准属性设置原型，解决之前通过 `Object.create` 定义原型，而没提供获取方法
4.  `Object.setPrototypeOf` 设置对象原型

这几种方式都可以管理原型，一般以我个人情况来讲使用 `prototype` 更改构造函数原型，使用 `Object.setPrototypeOf` 与 `Object.getPrototypeOf` 获取或设置原型。

## 构造函数

### 原型属性

构造函数在被`new` 时把构造函数的原型（prototype）赋值给新对象。如果对象中存在属性将使用对象属性，不再原型上查找方法。

-   构造函数只会产生一个原型对象

对象的原型引用构造函数的原型对象，是在创建对象时确定的，当构造函数原型对象改变时会影响后面的实例对象。

### Constructor

构造函数的原型中包含属性 `constructor` 指向该构造函数，以下代码说明了这一点

以下代码直接设置了构造函数的原型将造成 `constructor` 丢失

正确的做法是要保证原型中的 `constructor`指向构造函数

### 使用优化

使用构造函数会产生函数复制造成内存占用，及函数不能共享的问题。

体验通过原型定义方法不会产生函数复制

下面演示使用原型为多个实例共享属性

将方法定义在原型上为对象共享，解决通过构造函数创建对象函数复制的内存占用问题

使用`Object.assign`一次设置原型方法来复用，后面会使用这个功能实现 Mixin 模式

### 体验继承

下面为 `Stu` 更改了原型为`User` 的实例对象，`lisi`是通过构造函数`Stu`创建的实例对象

-   `lisi`在执行`getName` 方法时会从自身并向上查找原型，这就是原型链特性
-   当然如果把 `getName` 添加到对象上，就不继续追溯原型链了

## 继承与多态

当对象中没使用的属性时，JS 会从原型上获取这就是继承在 JavaScript 中的实现。

### 继承实现

下面使用`Object.create` 创建对象，做为`Admin、Member`的原型对象来实现继承。

![image-20191120214826701](https://doc.houdunren.com/assets/img/image-20191120214826701.a67be927.png)

不能使用以下方式操作，因为这样会改变 User 的原型方法，这不是继承，这是改变原型

### 构造函数

有多种方式通过构造函数创建对象

因为有时根据得到的对象获取构造函数，然后再创建新对象所以需要保证构造函数存在，但如果直接设置了 `Admin.prototype` 属性会造成`constructor`丢失，所以需要再次设置`constructor`值。

使用`Object.defineProperty`定义来禁止遍历 constructor 属性

完全重写构建函数原型，只对后面应用对象有效

### 方法重写

下而展示的是子类需要重写父类方法的技巧。

### 多态

根据多种不同的形态产生不同的结果，下而会根据不同形态的对象得到了不同的结果。

## 深挖继承

继承是为了复用代码，继承的本质是将原型指向到另一个对象。

### 构造函数

我们希望调用父类构造函数完成对象的属性初始化，但像下面这样使用是不会成功的。因为此时 `this` 指向了 window，无法为当前对象声明属性。

解决上面的问题是使用 `call/apply` 为每个生成的对象设置属性

### 原型工厂

原型工厂是将继承的过程封装，使用继承业务简单化。

### 对象工厂

在原型继承基础上，将对象的生成使用函数完成，并在函数内部为对象添加属性或方法。

### Mixin 模式

`JS`不能实现多继承，如果要使用多个类的方法时可以使用`mixin`混合模式来完成。

-   `mixin` 类是一个包含许多供其它类使用的方法的类
-   `mixin` 类不用来继承做为其它类的父类

> 其他语言也有类似的操作比如`php` 语言中可以使用 `trait` 完成类似操作。

下面是示例中 `Admin`需要使用 `Request.prototype` 与 `Credit` 的功能，因为`JS` 是单继承，我们不得不将无关的类连接在一下，显然下面的代码实现并不佳

下面分拆功能使用 Mixin 实现多继承，使用代码结构更清晰。只让 `Admin` 继承 `User` 原型

`mixin` 类也可以继承其他类，比如下面的 `Create` 类获取积分要请求后台，就需要继承 `Request` 来完成。

-   `super` 是在 `mixin` 类的原型中查找，而不是在 `User` 原型中

### 实例操作

使用 `call/apply` 制作选项卡

![Untitled](https://doc.houdunren.com/assets/img/Untitled.71754c70.gif)
