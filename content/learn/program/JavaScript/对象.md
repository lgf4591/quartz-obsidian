---
aliases: [对象 ]
author: lgf
created: 45_2022-11-12 19:15:01
modified: 45_2022-11-12 19:55:51
tags: [learn/program/javascript]
title: 对象 
---
# 对象
## 基础知识

> 向军大叔每晚八点在 [抖音 (opens new window)](https://live.douyin.com/houdunren) 和 [bilibli (opens new window)](https://space.bilibili.com/282190994) 直播

对象是包括属性与方法的数据类型，JS 中大部分类型都是对象如 `String/Number/Math/RegExp/Date` 等等。

传统的函数编程会有错中复杂的依赖很容易创造意大利式面条代码。

**面向过程编程**

**面向对象编程**

下面使用对象编程的代码结构清晰，也减少了函数的参数传递，也不用担心函数名的覆盖

### OOP

-   对象是属性和方法的集合即封装
-   将复杂功能隐藏在内部，只开放给外部少量方法，更改对象内部的复杂逻辑不会对外部调用造成影响即抽象
-   继承是通过代码复用减少冗余代码
-   根据不同形态的对象产生不同结果即多态

### 基本声明

使用字面量形式声明对象是最简单的方式

属性与方法简写

其实字面量形式在系统内部也是使用构造函数 `new Object`创建的，后面会详细介绍构造函数。

### 操作属性

使用点语法获取

使用`[]` 获取

可以看出使用`.`操作属性更简洁，`[]`主要用于通过变量定义属性的场景

如果属性名不是合法变量名就必须使用扩号的形式了

对象和方法的属性可以动态的添加或删除。

### 对象方法

定义在对象中的函数我们称为方法，下面定义了学生对象，并提供了计算平均成绩的方法

> 一个学生需要手动创建一个对象，这显然不实际的，下面的构造函数就可以解决这个问题

### 引用特性

对象和函数、数组一样是引用类型，即复制只会复制引用地址。

对象做为函数参数使用时也不会产生完全赋值，内外共用一个对象

对多的比较是对内存地址的比较所以使用 `==` 或 `===` 一样

### This

`this` 指当前对象的引用，始终建议在代码内部使用`this` 而不要使用对象名，不同对象的 this 只指向当前对象。

下例是不使用 `this` 时发生的错误场景

-   删除了`xj` 变量，但在函数体内还在使用`xj`变量造成错误
-   使用 `this` 后始终指向到引用地址，就不会有这个问题

改用`this` 后一切正常

### 展开语法

使用`...`可以展示对象的结构，下面是实现对象合并的示例

下面是函数参数合并的示例

## 对象转换

### 基础知识

对象直接参与计算时，系统会根据计算的场景在 `string/number/default` 间转换。

-   如果声明需要字符串类型，调用顺序为 `toString > valueOf`
-   如果场景需要数值类型，调用顺序为 `valueOf > toString`
-   声明不确定时使用 `default` ，大部分对象的 `default` 会当数值使用

下面的数值对象会在数学运算时转换为 `number`

如果参数字符串运长时会转换为 `string`

下面当不确定转换声明时使用 `default` ，大部分`default`转换使用 `number` 转换。

### Symbol.toPrimitive

内部自定义`Symbol.toPrimitive`方法用来处理所有的转换场景

### valueOf/toString

可以自定义`valueOf` 与 `toString` 方法用来转换，转换并不限制返回类型。

## 解构赋值

解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构，在数组章节已经介绍过。

-   建设使用 `var/let/const` 声明

### 基本使用

下面是基本使用语法

函数返回值直接解构到变量

函数传参

系统函数解构练习，这没有什么意义只是加深解构印象

### 严格模式

非严格模式可以不使用声明指令，严格模式下必须使用声明。所以建议使用 let 等声明。

还是建议使用`let`等赋值声明

### 简洁定义

如果属性名与赋值的变量名相同可以更简洁

只赋值部分变量

可以直接使用变量赋值对象属性

### 嵌套解构

可以操作多层复杂数据结构

### 默认值

为变量设置默认值

使用默认值特性可以方便的对参数预设

### 函数参数

数组参数的使用

对象参数使用方法

对象解构传参

## 属性管理

### 添加属性

可以为对象添加属性

### 删除属性

使用`delete` 可以删除属性（后面介绍的属性特性章节可以保护属性不被删除）

### 检测属性

`hasOwnProperty`检测对象自身是否包含指定的属性，不检测原型链上继承的属性。

下面通过数组查看

使用 `in` 可以在原型对象上检测

### 获取属性名

使用 `Object.getOwnPropertyNames` 可以获取对象的属性名集合

### Assign

以往我们使用类似`jQuery.extend` 等方法设置属性，现在可以使用 `Object.assign` 静态方法

从一个或多个对象复制属性

### 计算属性

对象属性可以通过表达式计算定义，这在动态设置属性或执行属性方法时很好用。

使用计算属性为文章定义键名

### 传值操作

对象是引用类型赋值是传址操作，后面会介绍对象的深、浅拷贝操作

## 遍历对象

### 获取内容

使用系统提供的 API 可以方便获取对象属性与值

### for/in

使用`for/in`遍历对象属性

### for/of

`for/of`用于遍历迭代对象，不能直接操作对象。但`Object`对象的`keys/`方法返回的是迭代对象。

获取所有对象属性

同时获取属性名与值

使用扩展语法同时获取属性名与值

添加元素 DOM 练习

## 对象拷贝

对象赋值时复制的内存地址，所以一个对象的改变直接影响另一个

### 浅拷贝

使用`for/in`执行对象拷贝

`Object.assign` 函数可简单的实现浅拷贝，它是将两个对象的属性叠加后面对象属性会覆盖前面对象同名属性。

使用展示语法也可以实现浅拷贝

### 深拷贝

浅拷贝不会将深层的数据复制

是完全的复制一个对象，两个对象是完全独立的对象

## 构建函数

对象可以通过内置或自定义的构造函数创建。

### 工厂函数

在函数中返回对象的函数称为工厂函数，工厂函数有以下优点

-   减少重复创建相同类型对象的代码
-   修改工厂函数的方法影响所有同类对象

使用字面量创建对象需要复制属性与方法结构

使用工厂函数可以简化这个过程

### 构造函数

和工厂函数相似构造函数也用于创建对象，它的上下文为新的对象实例。

-   构造函数名每个单词首字母大写即`Pascal` 命名规范
-   `this`指当前创建的对象
-   不需要返回`this`系统会自动完成
-   需要使用`new`关键词生成对象

如果构造函数返回对象，实例化后的对象将是此对象

### 严格模式

在严格模式下方法中的`this`值为 undefined，这是为了防止无意的修改 window 对象

### 内置构造

JS 中大部分数据类型都是通过构造函数创建的。

字面量创建的对象，内部也是调用了`Object`构造函数

### 对象函数

在`JS`中函数也是一个对象

函数是由系统内置的 `Function` 构造函数创建的

下面是使用内置构造函数创建的函数

## 抽象特性

将复杂功能隐藏在内部，只开放给外部少量方法，更改对象内部的复杂逻辑不会对外部调用造成影响即抽象。

下面的手机就是抽象的好例子，只开放几个按钮给用户，复杂的工作封装在手机内部，程序也应该如此。

![img](https://doc.houdunren.com/assets/img/iphone.911b431b.jpg)

### 问题分析

下例将对象属性封装到构造函数内部

### 抽象封装

上例中的方法和属性仍然可以在外部访问到，比如 `info`方法只是在内部使用，不需要被外部访问到这会破坏程序的内部逻辑。

下面使用闭包特性将对象进行抽象处理

## 属性特征

JS 中可以对属性的访问特性进行控制。

### 查看特征

使用 `Object.getOwnPropertyDescriptor`查看对象属性的描述。

使用 `Object.getOwnPropertyDescriptors`查看对象所有属性的描述

属性包括以下四种特性

| 特性         | 说明                                                    | 默认值    |
| ------------ | ------------------------------------------------------- | --------- |
| configurable | 能否使用 delete、能否需改属性特性、或能否修改访问器属性 | true      |
| enumerable   | 对象属性是否可通过 for-in 循环，或 Object.keys() 读取   | true      |
| writable     | 对象属性是否可修改                                      | true      |
| value        | 对象属性的默认值                                        | undefined |

### 设置特征

使用`Object.defineProperty` 方法修改属性特性，通过下面的设置属性 name 将不能被遍历、删除、修改。

通过执行以下代码对上面配置进行测试，请分别打开注释进行测试

使用 `Object.defineProperties` 可以一次设置多个属性，具体参数和上面介绍的一样。

### 禁止添加

`Object.preventExtensions` 禁止向对象添加属性

`Object.isExtensible` 判断是否能向对象中添加属性

### 封闭对象

`Object.seal()`方法封闭一个对象，阻止添加新属性并将所有现有属性标记为 `configurable: false`

`Object.isSealed` 如果对象是密封的则返回 `true`，属性都具有 `configurable: false`。

### 冻结对象

`Object.freeze` 冻结对象后不允许添加、删除、修改属性，writable、configurable 都标记为`false`

`Object.isFrozen()`方法判断一个对象是否被冻结

## 属性访问器

getter 方法用于获得属性值，setter 方法用于设置属性，这是 JS 提供的存取器特性即使用函数来管理属性。

-   用于避免错误的赋值
-   需要动态监测值的改变
-   属性只能在访问器和普通属性任选其一，不能共同存在

### getter/setter

向对是地用户的年龄数据使用访问器监控控制

下面使用 getter 设置只读的课程总价

下面通过设置站网站名称与网址体验`getter/setter`批量设置属性的使用

下面是设置 token 储取的示例，将业务逻辑使用`getter/setter`处理更方便，也方便其他业务的复用。

定义内部私有属性

### 访问器描述符

使用 `defineProperty` 可以模拟定义私有属性，从而使用面向对象的抽象特性。

上面的代码也可以使用语法糖 `class`定义

### 闭包访问器

下面结合闭包特性对属性进行访问控制

-   下例中访问器定义在函数中，并接收参数 v
-   在 get() 中通过闭包返回 v
-   在 set() 中修改了 v，这会影响 get()访问的闭包数据 v

## 代理拦截

代理（拦截器）是对象的访问控制，`setter/getter` 是对单个对象属性的控制，而代理是对整个对象的控制。

-   读写属性时代码更简洁
-   对象的多个属性控制统一交给代理完成
-   严格模式下 `set` 必须返回布尔值

### 使用方法

### 代理函数

如果代理以函数方式执行时，会执行代理中定义 `apply` 方法。

-   参数说明：函数，上下文对象，参数

下面使用 `apply` 计算函数执行时间

### 截取字符

下例中对数组进行代理，用于截取标题操作

### 双向绑定

下面通过代理实现`vue` 等前端框架的数据绑定特性特性。

![Untitled](https://doc.houdunren.com/assets/img/Untitled-5190245.5087f5bc.gif)

### 表单验证

![Untitled](https://doc.houdunren.com/assets/img/Untitled-1059910.07b17933.gif)

## JSON

-   json 是一种轻量级的数据交换格式，易于人阅读和编写。
-   使用`json` 数据格式是替换 `xml` 的最佳方式，主流语言都很好的支持`json` 格式。所以 `json` 也是前后台传输数据的主要格式。
-   json 标准中要求使用双引号包裹属性，虽然有些语言不强制，但使用双引号可避免多程序间传输发生错误语言错误的发生。

### 声明定义

**基本结构**

**数组结构**

### 序列化

序列化是将 `json` 转换为字符串，一般用来向其他语言传输使用。

根据第二个参数指定保存的属性

第三个是参数用来控制 TAB 数量，如果字符串则为前导字符。

为数据添加 `toJSON` 方法来自定义返回格式

### 反序列化

使用 `JSON.parse` 将字符串 `json` 解析成对象

使用第二个参数函数来对返回的数据二次处理

## Reflect

**Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法

-   `Reflect`并非一个构造函数，所以不能通过 new 运算符对其进行调用
