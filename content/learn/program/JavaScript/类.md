---
aliases: [类 ]
author: lgf
created: 45_2022-11-12 19:15:01
modified: 45_2022-11-12 19:56:19
tags: [learn/program/javascript]
title: 类 
---
# 类
## 基础知识

为了和其他语言继承形态一致，JS提供了`class` 关键词用于模拟传统的`class` ，但底层实现机制依然是原型继承。

`class` 只是语法糖为了让类的声明与继承更加简洁清晰。

### 声明定义

可以使用类声明和赋值表达式定义类，推荐使用类声明来定义类

类方法间不需要逗号

### 构造函数

使用 `constructor` 构造函数传递参数，下例中`show`为构造函数方法，`getName`为原型方法

-   `constructor` 会在 new 时自动执行

构造函数用于传递对象的初始参数，但不是必须定义的，如果不设置系统会设置如下类型

-   子构造器中调用完`super` 后才可以使用 `this`
-   至于 `super` 的概念会在后面讲到

### 原理分析

类其实是函数

`constructor` 用于定义函数代码，下面是与普通函数的对比，结构是一致的

![image-20191211115419286](https://doc.houdunren.com/assets/img/image-20191211115419286.27a4a5f1.png)

在类中定义的方法也保存在函数原型中

![image-20191211120949421](https://doc.houdunren.com/assets/img/image-20191211120949421.72c0f269.png)

所以下面定义的类

与下面使用函数的定义是一致的

### 属性定义

在 `class` 中定义的属性为每个`new` 出的对象独立创建，下面定义了 `site` 与 `name` 两个对象属性

### 函数差异

`class` 是使用函数声明类的语法糖，但也有些区别

`class` 中定义的方法不能枚举

### 严格模式

`class` 默认使用`strict` 严格模式执行

## 静态访问

### 静态属性

静态属性即为类设置属性，而不是为生成的对象设置，下面是原理实现

在 `class` 中为属性添加 `static` 关键字即声明为静态属性

-   可以把为所有对象使用的值定义为静态属性

### 静态方法

指通过类访问不能使用对象访问的方法，比如系统的`Math.round()`就是静态方法

-   一般来讲方法不需要对象属性参与计算就可以定义为静态方法

下面是静态方法实现原理

在 `class` 内声明的方法前使用 `static` 定义的方法即是静态方法

下面使用静态方法在课程类中的使用

## 访问器

使用访问器可以对对象的属性进行访问控制，下面是使用访问器对私有属性进行管理。

### 语法介绍

-   使用访问器可以管控属性，有效的防止属性随意修改
-   访问器就是在函数前加上 `get/set`修饰，操作属性时不需要加函数的扩号，直接用函数名

## 访问控制

设置对象的私有属性有多种方式，包括后面章节介绍的模块封装。

### Public

`public` 指不受保护的属性，在类的内部与外部都可以访问到

### Protected

protected是受保护的属性修释，不允许外部直接操作，但可以继承后在类内部访问，有以下几种方式定义

#### 命名保护

将属性定义为以 `_` 开始，来告诉使用者这是一个私有属性，请不要在外部使用。

-   外部修改私有属性时可以使用访问器 `setter` 操作
-   但这只是提示，就像吸烟时烟盒上的吸烟有害健康，但还是可以抽的

继承时是可以使用的

#### Symbol

下面使用 `Symbol`定义私有访问属性，即在外部通过查看对象结构无法获取的属性

#### WeakMap

**WeakMap** 是一组键/值对的集，下面利用`WeakMap`类型特性定义私有属性

也可以统一定义私有属性

### Private

`private` 指私有属性，只在当前类可以访问到，并且不允许继承使用

-   为属性或方法名前加 `#` 为声明为私有属性
-   私有属性只能在声明的类中使用

下面声明私有属性 `#host` 与私有方法 `check` 用于检测用户名

### 属性保护

保护属性并使用访问器控制

## 详解继承

### 属性继承

属性继承的原型如下

这就解释了为什么在子类构造函数中要先执行`super`

### 继承原理

`class` 继承内部使用原型继承

![image-20191211135724814](https://doc.houdunren.com/assets/img/image-20191211135724814.56b153b5.png)

### 方法继承

原生的继承主要是操作原型链，实现起来比较麻烦，使用 `class` 就要简单的多了。

-   继承时必须在子类构造函数中调用 super() 执行父类构造函数
-   super.show() 执行父类方法

下面是子类继承了父类的方法`show`

可以使用 `extends` 继承表达式返回的类

### Super

表示从当前原型中执行方法，

-   super 一直指向当前对象

下面是使用 `this` 模拟`super`，会有以下问题

-   但`this`指向当前对象，结果并不是 `admin`的`name`值

为了解决以上问题，需要调用父类方法时传递`this`

上面看似结果正常，但如果是多层继承时，会出现新的问题

-   因为始终传递的是当前对象`this` ，造成从 `this` 原型循环调用

为了解决以上问题 `js` 提供了 `super` 关键字

-   使用 `super` 调用时，在所有继承中 `this` 始终为调用对象
-   `super` 是用来查找当前对象的原型，而不像上面使用 `this` 查找原型造成死循环
-   也就是说把查询原型方法的事情交给了 `super`，`this` 只是单纯的调用对象在各个继承中使用

`super` 只能在类或对象的方法中使用，而不能在函数中使用，下面将产生错误

### Constructor

`super` 指调父类引用，在构造函数`constructor` 中必须先调用`super()`

-   `super()` 指调用父类的构造函数
-   必须在 `constructor` 函数里的`this` 调用前执行 `super()`

`constructor` 中先调用 `super` 方法的原理如下

### 父类方法

使用`super` 可以执行父类方法

-   不添加方法名是执调用父类构造函数

下面是通过父类方法获取课程总价

### 方法覆盖

子类存在父类同名方法时使用子类方法

下面是覆盖父类方法，只获取课程名称

### 静态继承

静态的属性和方法也是可以被继承使用的，下面是原理分析

下面使用 `class` 来演示静态继承

### 对象检测

### Instanceof

使用 `instanceof` 用于检测，下面是在原型中的分析（已经在原型与继承中讲过）

下面是递归检测原型的代码，帮助你分析 `instanceof` 的原理

`class` 内部实现就是基于原型，所以使用`instanceof` 判断和上面原型是一样的

### isPrototypeOf

使用 `isPrototypeOf` 判断一个对象是否在另一个对象的原型链中，下面是原理分析

下面在使用 `class` 语法中使用

### 继承内置类

使用原型扩展内置类

使用 `class`扩展内置类

### Mixin

关于`mixin` 的使用在原型章节已经讨论过，在`class` 使用也是相同的原理

`JS`不能实现多继承，如果要使用多个类的方法时可以使用`mixin`混合模式来完成。

-   `mixin` 类是一个包含许多供其它类使用的方法的类
-   `mixin` 类不用来继承做为其它类的父类

> 其他语言也有类似的操作比如`php` 语言中可以使用 `trait` 完成类似操作

### 实例操作

![Untitled](https://doc.houdunren.com/assets/img/Untitled-6121570.ae02deb6.gif)
